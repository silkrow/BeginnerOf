* Various Unix-like systems on the market:
	- All commerciail variants were derived from either SVR4 or 4.4BSD.
	- All tend to agree on some common standards like IEEE's Portable Operating Systems based on Unix(POSIX) and X/Open's Common Applications Environment(CAE).

* Linux vs. Unix kernels:
	- Monolithic kernel: 
		Linux + most commercial Unix variants.
		However Mac OS X and GNU Hurd are microkernel.
	- Compiled and statically linked traditional Unix kernels:
		Most modern kernels can DYNAMICALLY load and unload some portions of the kernel code(typically, device drivers). 
		Linux's support for modules: 
			allows to automatically load and unload modules on demand. 
	- Kernel threading:
		Linux uses kernel threads in a very limited way to execute a few functions periodically. 
	- Multithreaded application support:
		- Most modern operating systems have some kind of support for multithreaded applications.
		- Multithreaded user applications: 
			"user programs that are designed in terms of many relatively independent execution flows that share a large portion of the application data structures. Be composed of many lightweight processes(LWP)"
			- LWP:
				"processes that can operate on a common address space, common physical memory pages, common opened files..." 
				- Other commercial Unix variants of LWP are based on kernel threads.
				- Linux regards LWP as the basic execution context and handles them via the nonstandard clone() system call. 
	- Preemptive kernel:
		"When compiled with the Preemptible Kernel option, Linux 2.6 can arbitrarily interleave execution flows while they are in privileged mode."
		Linux has Preemptible Kernel option starting from 2.6
	- Multiprocessor support:
		Linux 2.6 supports symmetric mutiprocessing(SMP) for different memory models.

* Multiuser Systems:
	"A computer that is able to concurrently + independently execute several applications belonging to two or more users."
	- Applications can be active AT THE SAME TIME and contend for the various resources such as CPU, memory, hard disks...
	- Each application can perform its task with no concern for what others are doing.
	- Users and Groups: 
		- All users are identified by a unique number called User ID or UID.
		- Each user is a member of one or more user groups, which are identified by a unique number called a user group ID. Each file is associated with exactly one group. 
		- root/superuser:
			"Any Unix-like" OS has a special user called root or superuser. The root user can access every file on the system and can manipulate every running user program. 

* Process:
	"An instance of a program in execution. Processes are often called tasks or threads in the Linux source code. It can be imagined as the collection of data structures that fully describes how far the execution of the program has progressed."
	- Thread: 
		"Represents an execution flow of the process, they are independent, but share a large portion of the application data structures."
	- Linux uses lightweight processes to offer better support for multithreaded applications. Two lightweight processes may share some resources.
	- Multithreaded Application:
		A straightforward way to implement multithreaded applications is to associate a lightweight process with each thread. ---> the threads can access the same set of application data structures ++++++ each thread can be scheduled independently by the kernel so that one may sleep while another remains runnable.
	- Process Descriptor(PD for short):
		"A task_structure type structure with fields containing all the info related to a single process."
		including the following - fields.
		- state:
			an array; flags mutually exclusive
		- thread_info
		- mm
		- tty
		- parent
		- real_parent
		- fs
		- thread
		- files
		- pid
		...
	- To identify a process:
		1. PID:
			numbered sequentially; stored in the process descriptor; when upper limit is reached(32767 by default), the lower unused PIDs will be recycled; distinguishable for process(including lightweight); threads in the same group have common PID ==> thread group
		2. By distinct Process Descriptor:
			even lightweight processes have their own PD; each process has a 32-bit PD pointer which points to its task_struct(which is PD).
	- Thread group:
		- threads with a common PID.
		- a thread group leader(first lightweight process in the group) has its PID = tgid 
		- tgid: a field in PD, returned when getpid() is called, thus make sure all threads be led are seemed to share a single PID which is the leader's.
	- Memory Storage:
		- PD's are stored in dynamic memory rather than in the memory area permanently assigned to the kernel(instead use the thread_info below to link to PD from the memory area for each process).
		- Each process ____thread_info data structure 
					\______Kernel Mode process stack
			The two data structures above are stored together, 8192 bytes in total. 
			thread_info links to PD which is at somewhere else(but still it should be kernel space, not necessarily permanent).
			visualize the 2 page frames:

			0x015fbfff	|-------------------|
						| _________________	|
						| |		Stack	  |	|
						| |				  |	|
			0x015fb000	| |				  |	|
						|         .			|
						|		  .			|
						|		  .			|
				esp --> | |_______________|	|
						|					|
						|					|
			0x015fa034	|  _______________	| 
						| |	52 bytes fixed|	|
						| |	thread_info	--|-|--> PD
						| |_______________|	|
			0x015fa000	|-------------------|
			the structure above provides a convenient way for the kernel to identify process since it can use the esp register and erase lower bits to get to thread_info structure.
		- process list:
			"A doubly linked list that links together all existing PD's"
		- runqueue:
			- Early Linux put all runnable processes in the same list called runqueue.
			- 2.6 splits the runqueue in many lists of runnable processes, by process priority(an int in 0-139).
	- Relationships:
		fields in PD(given a process P):
			- real_parent: 
				"Points to the PD that created P, or to process 1 if parent of P no longer exists."
			- parent:
				"Points to the current parent of P. This is the process that must be signaled when P terminates. It maybe different with real_parent when another process issues a ptrace() syscall requesting that it be allowed to monitor P."
			- children:
				"The head of list containing all children created by P."
			- sibling:
				"Pointers to the next and prev elements in the list of the sibling processes."
	- Process Resource Limits:
		"Specify the amount of system resources it can use." Stored in a field called rlimit in the PD.
	- Process Switch:
		

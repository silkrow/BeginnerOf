* Various Unix-like systems on the market:
	- All commerciail variants were derived from either SVR4 or 4.4BSD.
	- All tend to agree on some common standards like IEEE's Portable Operating Systems based on Unix(POSIX) and X/Open's Common Applications Environment(CAE).

* Linux vs. Unix kernels:
	- Monolithic kernel: 
		Linux + most commercial Unix variants.
		However Mac OS X and GNU Hurd are microkernel.
	- Compiled and statically linked traditional Unix kernels:
		Most modern kernels can DYNAMICALLY load and unload some portions of the kernel code(typically, device drivers). 
		Linux's support for modules: 
			allows to automatically load and unload modules on demand. 
	- Kernel threading:
		Linux uses kernel threads in a very limited way to execute a few functions periodically. 
	- Multithreaded application support:
		- Most modern operating systems have some kind of support for multithreaded applications.
		- Multithreaded user applications: 
			"user programs that are designed in terms of many relatively independent execution flows that share a large portion of the application data structures. Be composed of many lightweight processes(LWP)"
			- LWP:
				"processes that can operate on a common address space, common physical memory pages, common opened files..." 
				- Other commercial Unix variants of LWP are based on kernel threads.
				- Linux regards LWP as the basic execution context and handles them via the nonstandard clone() system call. 
	- Preemptive kernel:
		"When compiled with the Preemptible Kernel option, Linux 2.6 can arbitrarily interleave execution flows while they are in privileged mode."
		Linux has Preemptible Kernel option starting from 2.6
	- Multiprocessor support:
		Linux 2.6 supports symmetric mutiprocessing(SMP) for different memory models.

* Multiuser Systems:
	"A computer that is able to concurrently + independently execute several applications belonging to two or more users."
	- Applications can be active AT THE SAME TIME and contend for the various resources such as CPU, memory, hard disks...
	- Each application can perform its task with no concern for what others are doing.
	- Users and Groups: 
		- All users are identified by a unique number called User ID or UID.
		- Each user is a member of one or more user groups, which are identified by a unique number called a user group ID. Each file is associated with exactly one group. 
		- root/superuser:
			"Any Unix-like" OS has a special user called root or superuser. The root user can access every file on the system and can manipulate every running user program. 

* Process:
	"An instance of a program in execution. Processes are often called tasks or threads in the Linux source code. It can be imagined as the collection of data structures that fully describes how far the execution of the program has progressed."
	- Thread: 
		"Represents an execution flow of the process, they are independent, but share a large portion of the application data structures."
	- Linux uses lightweight processes to offer better support for multithreaded applications. Two lightweight processes may share some resources.
	- Multithreaded Application:
		A straightforward way to implement multithreaded applications is to associate a lightweight process with each thread. ---> the threads can access the same set of application data structures ++++++ each thread can be scheduled independently by the kernel so that one may sleep while another remains runnable.
	- Process Descriptor(PD for short):
		"A task_structure type structure with fields containing all the info related to a single process."
		including the following - fields.
		- state:
			an array; flags mutually exclusive
		- thread_info
		- mm
		- tty
		- parent
		- real_parent
		- fs
		- thread
		- files
		- pid
		...
	- To identify a process:
		1. PID:
			numbered sequentially; stored in the process descriptor; when upper limit is reached(32767 by default), the lower unused PIDs will be recycled; distinguishable for process(including lightweight); threads in the same group have common PID ==> thread group
		2. By distinct Process Descriptor:
			even lightweight processes have their own PD; each process has a 32-bit PD pointer which points to its task_struct(which is PD).
	- Thread group:
		- threads with a common PID.
		- a thread group leader(first lightweight process in the group) has its PID = tgid 
		- tgid: a field in PD, returned when getpid() is called, thus make sure all threads be led are seemed to share a single PID which is the leader's.
	- Memory Storage:
		- PD's are stored in dynamic memory rather than in the memory area permanently assigned to the kernel(instead use the thread_info below to link to PD from the memory area for each process).
		- Each process ____thread_info data structure 
					\______Kernel Mode process stack
			The two data structures above are stored together, 8192 bytes in total. 
			thread_info links to PD which is at somewhere else(but still it should be kernel space, not necessarily permanent).
			visualize the 2 page frames:

			0x015fbfff	|-------------------|
						| _________________	|
						| |		Stack	  |	|
						| |				  |	|
			0x015fb000	| |				  |	|
						|         .			|
						|		  .			|
						|		  .			|
				esp --> | |_______________|	|
						|					|
						|					|
			0x015fa034	|  _______________	| 
						| |	52 bytes fixed|	|
						| |	thread_info	--|-|--> PD
						| |_______________|	|
			0x015fa000	|-------------------|
			the structure above provides a convenient way for the kernel to identify process since it can use the esp register and erase lower bits to get to thread_info structure.
		- process list:
			"A doubly linked list that links together all existing PD's"
		- runqueue:
			- Early Linux put all runnable processes in the same list called runqueue.
			- 2.6 splits the runqueue in many lists of runnable processes, by process priority(an int in 0-139).
	- Relationships:
		fields in PD(given a process P):
			- real_parent: 
				"Points to the PD that created P, or to process 1 if parent of P no longer exists."
			- parent:
				"Points to the current parent of P. This is the process that must be signaled when P terminates. It maybe different with real_parent when another process issues a ptrace() syscall requesting that it be allowed to monitor P."
			- children:
				"The head of list containing all children created by P."
			- sibling:
				"Pointers to the next and prev elements in the list of the sibling processes."
	- Process Resource Limits:
		"Specify the amount of system resources it can use." Stored in a field called rlimit in the PD.
	- Process Switch:
		1. hardware context: 
			- Things in registers must be stored/pre-loaded during the switch, the set of data that must be loaded into the registers before process resumes is called "hardware context". In Linux, a part of the hardware context is stored in the PD, while the remaining is saved in the Kernel Mode stack.
			- Old versions use hardware support to do hardware context switch... Linux 2.6 uses software to perform a process switch... The 2 ways take about the same amount of time.
			- Don't worry about registers for User Mode, they are stored already in Kernel Mode stack before performing the process switch.
		2. Task State Segment(TSS):
			- 80x86 architecture includes a specific segment type called the Task State Segment(TSS), to store hardware contexts.
			- Linux doesnt's use hardware to perform the hardware context switch, but it forces each CPU to have a TSS.
			- Check ULK3 p104 for details about Task State Segment.
		3. Steps of process switch:
			1) Switch the Page Global Directory to install a new address space
			2) Switch the Kernel Mode stack and the hardware context
	- Create Processes:
		Modern speed ups:
			- COW
			- lightweight process: 
				allow both the parent and the child to share many per-process kernel data structures.
			- vfork() syscall:
				creates a process that shares the memory address space of its parent, the parent's execution is blocked until the child exits or executes a new program.	
		syscalls:
			- clone():
				- Creates a lightweight process.
				- It actually sets up the stack of the new lightweight process and then invokes the clone() system call. So clone() called by application is but a wrapper function in C library.
			- fork():
				- a clone() syscall whose flags parameter specifies both a SIGCHLD signal and all the clone flags cleared, and whose child_stack parameter is the current parent stack pointer.
				- the parent and child temporarily share the same User Mode stack.
			- vfork():
				- a clone syscall whose flags parameter specifies both a SIGCHLD signal and the flags CLONE_VM and CLONE_VFORK, and whose child_stack parameter is the current parent stack pointer.
			---
			wrap up:
			clone() ___ a function with many paras and flags 
				\___ in fact a wrapper function in C lib, sets up the stack of the new lightweight handle some paras and triggers clone() syscall. 
			fork() ___ clone() syscall with SIGCHLD signal and no flags
			vfork() ___ clone() syscall with SIGCHLD signal and flag CLONE_VM | CLONE_VFORK
												\___ Let User Mode sp to be assigned to the esp of the child process(parent and child temporarily share the same User Mode stack)
		- visualize:
			|-----------------------|
			| clone() in C library	|
			|-----------------------|-----------|-----------------------------------|
			|		clone()			| + SIGCHLD	| + SIGCHLD + CLONE_VM|CLONE|VFORK  |
			|						| = fork()	| = vfork()							|
			|-----------------------|-----------|-----------------------------------|
							|								|
			 				|			do_fork()			|
							|-------------------------------|
							|			copy_process()		|
							|-------------------------------|
							
